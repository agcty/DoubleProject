\chapter{Evaluation}

\section{Project Objectives}
Every initially stated requirement in the form of user stories was met with the exception of being able to change an issue's status. As described in \autoref{issuelogs}, this is due the API not supporting it. A \acrlong{spa} was built that communicates with the API to provide the following functionality as per the requirements:

\begin{itemize}
    \item A Forum where users can add and edit threads and write comments
    \item Polls creatable by proprietors to guide decision making
    \item A digital Noticeboard where users can make announcements    
    \item An Issue Log System to submit and track issues
    \item Switching between the English and German language
\end{itemize}

Additionally, certain functionality had to be implemented which is not defined in the requirements but was implicitly needed:  
\begin{itemize}
    \item Authentication System
    \item Adding houses to a user's account
    \item Inviting users    
    \item Changing profile data
\end{itemize}

Before implementing the system, a thorough evaluation of use cases and use case flows was carried out. The flows were later used to identify UI elements that are used in multiple places. These were then translated into Vue components. Furthermore, the \acrshort{spa} can be easily adapted to support \acrlong{ssr} as it is based on Nuxt. A testing strategy was set up that incorporates continuous integration. Last but not least, Docker is used to deploy the system including frontend, backend, database and reverse proxy anywhere.

\section{Project Evaluation using Heuristics}
The User Interface design is evaluated by using the ten usability heuristics Nielsen and Molich developed.

\subsection{Visibility of System Status}
\begin{itemize}
    \item Always keep users informed about what is going on
    \item Provide appropriate feedback within reasonable time
\end{itemize}

\subsubsection{Evaluation}
For every request the user triggers, a loading bar indicates its progress. If it is successful, its color is green and the user will be redirect to the appropriate site containing all entries of that type. If it fails, its color is red and additionally a generic error message is displayed. By displaying an error message, colourblind users are also given a chance to see what went wrong. Additionally, at the start of the application a loading circle indicates that it is starting up. When inputing data into forms, they are automatically validated and appropriate messages are shown if the input is malformatted. \textbf{Conclusion}: The user is displayed the system status at appropriate times, however, error messages could be more specific.

\subsection{Match between system and the real world }

\begin{itemize}
    \item Speak the users' language, with words, phrases and concepts familiar to the user, rather than system-oriented terms
    \item Follow real-world conventions, making information appear in a natural and logical order
\end{itemize}

\subsubsection{Evaluation}
The system uses the terms: "Forum", "Polls", "Noticeboard" and "Issues" which are common in the real as well as the virtual world. Additionally, always the most recent entries are shown on top and every type of entry is based on its real world counterpart. For example, issues are displayed as a table, whereas Noticeboard entries are displayed as a black box. On some sites however, the word Noticeboard is swapped out with "Notices" or "Messages" which might be misleading. \textbf{Conclusion}: Most words and phrases are used in the system are also commonly used in the real world. Additionally, the design reflects the real world. "Noticeboard" is used in a somewhat incoherent manner and could be improved.

\subsection{User control and freedom}

\begin{itemize}
    \item Users often choose system functions by mistake
    \item Provide a clearly marked "out" to leave an unwanted state without having to go through an extended dialogue
    \item Support undo and redo.
\end{itemize}

\subsubsection{Evaluation}
The navigation bar used across the application allows for quick and easy page changes. Below every input form there is a "Cancel" button which redirects back to the previous page. Undo and redo are not supported at all. \textbf{Conclusion:} Users can easily leave an unwanted state but cannot undo or redo requests.


\subsection{Consistency and standards}

\begin{itemize}
    \item Users should not have to wonder whether different words, situations, or actions mean the same thing
    \item Follow platform conventions.
\end{itemize}

\subsubsection{Evaluation}
Across the application, different icons mean different things. Additionally, for every input form a title and subtitle indicate what it is used for. A very distinct design for every type of entry does not allow ambiguity. As already mentioned, the word "Noticeboard" is sometimes substituted with other words which is not very consistent. \textbf{Conclusion}: Most of the words, phrases and standards are consistent and a distinct look for different entries means no ambiguity.

\subsection{Error prevention}

\begin{itemize}
    \item Even better than good error messages is a careful design which prevents a problem from occurring in the first place
\end{itemize}

\subsubsection{Evaluation}
The highest probability of where errors can occur is when users input data into a form. If the user-generated input does not meet the requirements of the form, an error message is displayed and submitting the form is prevented until the user resolves all errors. \textbf{Conclusion}: Errors are prevented by not allowing the user to submit forms which would mutate the system's data if malformatted input is provided.

\subsection{Recognition rather than recall}

\begin{itemize}
    \item Make objects, actions, and options visible
    \item User should not have to remember information from one part of the dialogue to another
    \item Instructions for use of the system should be visible or easily retrievable whenever appropriate
\end{itemize}

\subsubsection{Evaluation}
Actions are always represented in the form of green buttons. Options are selectable through HTML select elements. Objects (Polls, Issues, etc) are clearly distinguishable from other elements. The application is built in a way that does not incorporate dialogues or mutliple steps 99\% of the time, which means there is no need to show information of a previous step in the current step. The only place where more information could be useful but not necessary is when users create a new house and are then given the possibility to invite other users. Currently, they are only prompted to invite a user to the house they just created, it would be better to display the house users are added to. \textbf{Conclusion}: Objects, actions and options are distinguishable and users immediately know what is each element is used for. The simplistic design of the application without multiple steps makes recalling unnecessary. Inviting a user could however, display more information.

\subsection{Flexibility and efficiency of use}

\begin{itemize}
    \item Novice and expert users use systems differently. The system should be easy and efficient to use by novices and experts alike
    \item Provide “accelerators” for expert users to more efficiently navigate your application to complete the most frequent tasks
\end{itemize}

\subsubsection{Evaluation}
Accelerators in the form of keystroke shortcuts are not implemented. The system's functionality is only usable by using the GUI. \textbf{Conclusion}: A complete lack of accelerators might lead to a degraded user experience for advanced users and should be implemented in a future iteration. Several libraries can easily be utilized to provide such functionality.

\subsection{Aesthetic and minimalist design}

\begin{itemize}
    \item Dialogues should not contain information which is irrelevant or rarely needed
    \item Every extra unit of information in a dialogue competes with the relevant units of information and diminishes their relative visibility
\end{itemize}

\subsubsection{Evaluation}
The application's dashboard shows information regarding Polls, Noticeboard Items, Threads and Issues. However, it is not differentiated between proprietors or tenants. This means an empty Polls placeholder is shown if the user is a tenant which is irrelevant and unnecessary. The subpages of the application already show only the minimally needed data. \textbf{Conclusion}: The application could differentiate more between user roles. The design is already as minimal as possible, only showing information which is crucially needed.

\subsection{Help users recognize, diagnose, and recover from errors}

\begin{itemize}
    \item Errors are expressed in plain language
    \item Precisely indicate the problem
    \item Constructively suggest a solution 
\end{itemize}

\subsubsection{Evaluation}
When a user inputs data into a form, it is automatically validated and shows an error message. However, some error messages do not indicate the problem nor suggest a solution. Only error messages generated from the client-side are appropriate. For example, a user inputs a malformatted email address and an error message appears indicating that this email address is not valid. On the other hand, if a user tries to create an account with an already existing email address, the application only shows a "Registering failed" error with no further information. \textbf{Conclusion}: Client-side errors are shown and a solution is implicitly displayed by saying the email address is not valid for example. API based errors are not appropriately shown.  

\subsection{Help and documentation}

\begin{itemize}
    \item Even though it is better if the system can be used without documentation, it may be necessary to provide help and documentation. 
    \item Help information should be easy to search, focused on the user's task, list concrete steps to be carried out, and not be too large.
\end{itemize}

\subsubsection{Evaluation}
The application does not provide any type of documentation. \textbf{Conclusion}: Although the application is easy to use, some user might still need additional resources and documentation. A documentation site should be created.

\section{System Design Evaluation}
As described in \autoref{ch:systemdesign}, the system is built with various technologies. NGINX is used as a webserver to serve the \acrshort{spa} which communicates with a Django-based API. A PostgreSQL database is used to store data and an Exchange Email Server is used to send emails to users. These services are encapsulated in their own containerized environment with Docker. Additionally, a traefik based reverse proxy routes between the services and provides automatic TLS certificates.

\subsection{SPA Framework}
A thorough literature-based evaluation of \acrshort{spa} frameworks has already been undertaken in \autoref{ch:litreview}. It concluded that Vue is the most performant, compact and easiest to learn framework. In addition, it was deemed the most appropriate framework to meet functional and non-functional requirements for this project in \autoref{sec:consideredtech}. The two main alternatives Angular and React would have been differently suitable. Angular scales very well for large corporate porjects but at the same time has a very steep learning curve. React on the other hand, is easier to learn than Angular but not as easy as Vue. However, it is more flexible and scales better for bigger applications. Given that the final application is quite large in terms of functionality and code lines, React would have been just as suitable as Vue. Vue was definitely the easiest framework to learn and completely matched any expectations, however, as the project grows it might be necessary to switch to something more scalable like React. 

\subsection{Webserver}
The main reason NGINX was chosen as a webserver is its high performance when serving static content \cite{NGINXvsApache:online}. In addition, it is very efficient when concurrently serving users \cite{NGINXvsApache:online}. Another possible alternative would be the usage of Apache's httpd webserver. However, as opposed to NGINX, it is not as efficient and performant when serving static content to mutltiple users concurrently, but instead excells at serving dynamic content \cite{NGINXvsApache:online}. Setting up NGINX was very easy: it did not need any special configuration whatsoever, as everything needed was already pre-configured by the Docker image. Not even https had to be set up as this is handled automatically by the reverse proxy for every container. 

\subsection{CSS Framework}
By using Buefy which is based on the Bulma CSS framework, a very distinct look of the application is achieved. In contrary to the widely used Bootstrap and Foundation framework, Bulma is not yet as ubiquituously used on the web. Another possible alternative would be "Vuetify" - which is based on the "Google Material Design Guidelines". Vuetify provides a very mature set of Vue components which are heavily tested and optimized for various screen sizes. While Bulma is not that heavily tested it is still very much optimized for mobile and desktop usage. Additionally, it met the most imporant requirement for this project: providing a distinct look and feel. 

\subsection{SSR Framework}
Nuxt is used as an SSR framework. Even thoguh \acrshort{ssr} is not needed for this project, Nuxt auto-configures routing and the store. Alternatively, the vue-cli could have been used to bootstrap the application, however, in doing so, the store and more importantly, routing would require a manual set up. Using Nuxt as an \acrshort{ssr} framework would not have been necessary but made took away some of the developers responsibilities and made building the application faster. For future projects that do not necessarily need \acrshort{ssr} due to being restricted to logged in users, I would recommend using the vue-cli instead even if it means setting up routing and the store manually. 

\subsection{Docker}
By using a containers to run applications/microservices, the development and production environment is effectively the same. This makes deployment and development much easier and faster. There are some alternatives: CoreOS rkt, Mesos Containerizer, LXC Linux Containers, OpenVZ or containerd. However, Docker is the de facto standard for building application-level containers. 

\subsection{Development Approach}
The used development approach "Kanban" could be substituted with the waterfall-model. Scrum on the other hand, is no viable alternative as it requires at least three team members. As opposed to the waterfall-model and Scrum, Kanban allows for specification changes during the development. Since the initial project requirements were quite vague and regularly needed expansion Kanban also was the most suitable approach and even complemented the iterative nature of the development process.

\subsection{Software Design}
Implementing the application's functionality would have been possible with React, Angular or Vue alike. The important part was to meet the non-functional requirements which include high flexibility, easy to maintain code and most importantly a low learning curve. By implementing the components in a very loosely coupled way (using props and events) and by making efforts to further separate concerns (e.g error handling only in UI components and not in store), the maintainability of the code was drastically improved. By extensively using events and props, a very modular architecture is achieved: e.g there always is a single entry item and a list composed of multiple items. The important part is that the list does not define which items are shown, rather, these items are passed as a prop from the page the list is contained in. At the same time, by using a Search Bar, which emits the current input as an event, this list of items can be filtered and manipulated in the page which then rerenders the shown items in the list. The Search Bar could be even substituted by any other type of input component and the list component would still be able to show the filtered items because the logic does not reside in list nor Search Bar components. The benefit with such an approach is that the components are so loosely coupled, that it would be possible to just copy them to another project and they would still work. If a list component would instead retrieve data from the store, this would not be possible anymore.

During the application's development, it was also important to write HTML in a semantically correct manner. For example every form uses the native HTML "form" element with input elements inside it and a button of type "submit". When the button is pressed, the form catches the event and executes an appropriate function. Another common way is to not use the form element but to only use input elements and define a click listener for the button. This however, is semantically not correct - even though all major modern browsers can handle such forms, some functionaly such as screen-reading for blind persons might be disabled because the browser does explicitly know that the user currently uses a form.

\subsection{Costs \& Benefits}
As every technology used to build the system is open source, no costs apply. Only the \acrshort{vps} from DigitalOcean costs a varying amount of money. The technical plan initally stated an amount of 39£ / month which included two \acrshort{vps} instances. However, as Docker and Docker Swarm are used, a single \acrshort{vps} in its basic version can be used, which brings costs down to around 4£ per month. In the case of increased user loads, additional \acrshort{vps} instances can be created and Docker Swarm automatically distributes containers across them. The initial estimate of working time hours was exceeded by roughly 100 hours. Depending on the point of view, the monetary benefit for the developer would be higher they worked 100 hours for free.

\section{Commercial Applicability}
As the idea of building an application that allows tenants, proprietors and facility management to manage their properties initially arose from real world problems, there is definitely a market for these types of applications. In Austria, the company behind "IDWELL" - an application to manage properites through CRM, already caters to these types of users. The next step would be to release the application as a Minimum Viable Product, conduct user interviews to identify if they actually use the system and in which manner and then adapt the software accordingly.

\section{Self Reflection}
Throughout the project, I have learned a considerable amount regarding software engineering and myself as a person. I have improved my programming skills and my understanding of building UIs. As I already had experience with Vue and other \acrshort{spa} frameworks it was more important for me to improve the quality of the overall system. What I enjoyed learning the most was Docker and continuous integration and how they can complement each other. As these are two things that do not only apply to frontend development (which changes rapidly) but can be used for any type of project, I have successfully learned two technologies and their underlying paradigms that will be relevant for a long period of time. The courses taught at UCLAN, especially "Object Oriented Methods" and "Advanced Software Engineering Techniques" also very much helped in achieving my project goals by giving me a thorough understanding of relevant concepts for any type of software. Last but not least, the extra-curricalar activity of Jiu Jitsu gave me the will to push forward and persevere, even in times when I did not think I could solve a complex problem. 

\section{Future Work}
In order to improve the overall system I would focus on three things: more functionality, even more sophisticated deployment system and additional testing. To elaborate further, more functionality could include 1) Securely storing documents about a house, 2) Automated tasks for advanced users (e.g uploading a list of houses which are then automatically created) and 3) Chat functionality.

Storing documents would need some kind of distributed storage, existing solutions like Amazon AWS and DigitalOcean Spaces provide several hundred GB of data storage for a very small amount of Pounds in exchange. It would definitely be easier and in the beginning - more secure, to use such services as they provide a thorougly documentend API and secure access and storage. Especially security is very hard to achieve as a single developer who also has other responsibilites like building the actual application and deploying it. Automated tasks are more a responsibility of the API than the application. The chat functionality could be implemented by using a library called "socket.io" which utilizes sockets to achieve real-time communication. When storing chats a thorough evaluation of NoSQL and SQL databases would be necessary.

Before implementing new functionality, the already existing features should be improved by solving the heuristics related issues identified in \autoref{ch:testing}. Additionally, end to end and integration tests would further reassure that nothing will break in production.

Instead of Docker Swarm, the project could use Kubernetes, a far more sophisticated tool for deploying and managing containers which has automatic logging and monitoring capabalities. What is more, it can auto-scale the deployment depending on the current user load.  

