\chapter[Project Planning]{Project Planning}

% \section{Methodology}
% https://zube.io/blog/agile-project-management-workflow-for-github-issues/
\section{Introduction} \label{sec:introplanning}
The project was to develop a front-end to an existing system and had to be planned accordingly. This chapter will give an overview about which parts of the system already exist and identifies the requirements and potential solutions for the frontend. Additionally, it depicts considered technologies and techniques and evaluates the most appropriate development stack.

The main idea is to give tenants, proprietors and facility management a way to communicate over a single point of access. In its first version, they should be able to discuss topics they care about, easily make announcements, submit and track the state of maintenance issues and create polls in order to provide an easy way for decision-making. The requirements are not "hard" requirements in a sense that a customer requirements document or something similar exists, rather they are written as informal user stories. It is the developer's responsiblity to develop feasible use cases and flows. It is also noteworthy to mention that this project will initially be realeased in Austria.

% Talk about project idea in more detail
\section{Provided Services}
% DB - postgresql
% API - documented with postman
A Database, Exchange Email Server and API are provided by the project partner. The first is a PostgreSQL instance, the latter an API built on top of Django and Django Rest Framework. These two technologies provide the backend of the system as a whole. The API is documented with Postman, describing each endpoint in terms of what type of data has to be sent and what data will be returned. Apart from making these compatible with a containerized environment (see \autoref{ch:deployment}), no further action has to be taken in order to use these services.

\section{Requirements} \label{sec:requirements}
% List requirements defined by project partner
% write these as user stories
% illustrate as Use Case diagram
As mentioned in the introduction, several functional requirements exist. Furthermore, there are some non-functional requirements for the project which have to be taken into account. \autoref{tab:requirements} depicts these general requirements. \newline

\begin{table}[H]
    \begin{center}
      \begin{tabularx}{\linewidth}{l|l} % <-- Alignments: 1st column left, 2nd middle and 3rd right, with vertical lines in between
        \textbf{Functional Requirements} & \textbf{Non-Functional Requirements}\\
        \hline
        Digital Noticeboard & High Flexibility \\
        Polls & Easy to maintain\\
        Forum & Easy way of creating apps for mobile phones from frontend\\
        Issue Management & Low learning curve for future developers\\
        Bilinguality & \\
      \end{tabularx}
      \caption{Project Requirements}
      \label{tab:requirements}
    \end{center}
  \end{table}

 
These very high functional requirements can be further broken down into user stories. The most important of which are illustrated along with additional information in the next few sections. For a full list of user stories please see (appendix user stories) The word "user" is used for referring to every user-group of the system. The specific user-groups are: Tenant, Proprietor, Facility Management.

\subsection{Digital Noticeboard}
\begin{table}[H]
  \begin{tabularx}{\linewidth}{l|X}
     Description & A unidirectional way of communication between house parties \\
     \hline
     User Story & As a user I want to make announcements so other users can act accordingly \\
     \hline
     Example & Announcing a get-together everyone is invited to 
  \end{tabularx}
\end{table}

\subsection{Polls}
\begin{table}[H]
  \begin{tabularx}{\linewidth}{l|X}
     Description & A method for decision-making \\
     \hline
     User Story & As a proprietor I want to create polls other proprietors can vote on so that we as a group can make decisions \\
     \hline
     Example & A facade that has to be repainted with a new color. To get an initial idea which color it should be, Proprietors can create polls and let other proprietors choose between given options \\
     \hline
     Notes & Polls should not be editable so proprietors cannot change their contents after someone voted
  \end{tabularx}
\end{table}

\subsection{Forum}
\begin{table}[H]
  \begin{tabularx}{\linewidth}{l|X}
     Description & A way of discussing topics related to a specific house \\
     \hline
     User Story & As a user I want to ask questions so other users can answer them \\
     \hline
     Example & A tenant wants to know when garbage cans are emptied
  \end{tabularx}
\end{table}

\subsection{Issue Management}
\begin{table}[H]
  \begin{tabularx}{\linewidth}{l|X}
     Description & A way of submitting and track the status of maintenance related issues \\
     \hline
     User Story & As a user I want to submit an issue so that it can be taken care of \\
     \hline
     Example & A user has a water leak and submits an issue, the facility management can access these issues and take action
  \end{tabularx}
\end{table}

\subsection{Bilinguality}
\begin{table}[H]
  \begin{tabularx}{\linewidth}{l|X}
     Description & Changing the language \\
     \hline
     User Story & As a user I want to change the language of the application so I can understand the content \\
     \hline
     Notes & It is important that users are able to choose between at least two languages. German is the most obvious choice as it is Austria's primarily spoken language. English, the second most well known language in Austria is obvious as well 
  \end{tabularx}
\end{table}

According to these requirements, a high-level use-case diagram as illustrated in \autoref{fig:usecases} can be generated. Additional information like basic flows of these use cases can be found in the respective section of \autoref{ch:implementation} which is in accordance with the "Decide as late as possible" principle found in lean development projects. \newline
% \textbf{Disclaimer:} This use case diagram only depicts uses cases which mutate the system's data. Naturally, users also want to view and filter data, these use cases are however omitted for brevity. Examples would be: "View Noticeboard Entries" and "Search Noticeboard Entry". 
% rewrite

\begin{figure}[H]
    \begin{center}
    \includegraphics[height=7in]{usecases3}
    \end{center}
    \caption{Proprietors Assembly Use Cases}
    \label{fig:usecases}
\end{figure}

\section{Considered Technologies} \label{sec:consideredtech}
% Single Page Application because interactive and functionality easy to integrate, smooth native-like feeling
% Using Vue because flexibility and ease of learning were important
\subsection{\acrshort{spa} Framework}
To meet both functional and non-functional requirements a \acrfull{spa} is a potential solution. They provide an interactive, smooth native-like user interface and can easily be transformed to a \acrfull{pwa} if the need arises. \acrshort{pwa}'s are a fairly new type of application that use traditional web-browser technology but can be run almost as if they are native applications. As illustrated in \autoref{fig:comparison}, an especially appropriate framework for developing this project can be found in Vue, which perfectly suits the needs of the non-functional requirements: as opposed to React or Angular, its relatively high flexibility in addition to its shallow learning curve allow for a rapid development process.

\subsection{\acrshort{ssr} Framework}
Although the project's requirements do not implicate the necessity of implementing any type of \acrfull{ssr}, it is possible that rapidly changing content such as publicly available blog posts with comments will be added in a future release. \autoref{sub:seo} identifies three ways of rendering \acrshort{spa}'s on the server side and explains in great detail why this is important. Developing the project from the start while keeping this information in mind could reduce long-term complexity. 

Server Side Rendering as defined in \autoref{subsub:ssr} would be the most viable option as it comes with the biggest advantages. It can be utilized in one of two ways: By using vue as a framework and the supporting library "vue-server-renderer" or by using an additional framework. The first way requires the developer to configure everything themselves whereas the latter provides pre-configured \acrshort{ssr} functionality. One of these frameworks is Nuxt.js which is the most  popular SSR framework within the vue community. In addition, it configures automatic routing and state management, which are described in more detail in chapter (Not yet written) . 

\subsection{CSS Framework}
% Bulma, vuetify, bootstrap, foundation
CSS frameworks can drastically decrease developing time for frontend projects as they provide predefined tools and components for creating user interfaces. There are various CSS frameworks available which differ greatly in design: in addition to the widely used Bootstrap and Foundation frameworks which have a very basic and familiar design, there are smaller ones which provide different design elements which could help distinguish the project from others. Such frameworks are "Bulma" or "Materialize". Bulma comes with a very distinct design, that does not seem to be used as widely on the web. Furthermore, the vue library "Buefy" builds on top of Bulma's CSS and provides predefined vue components to use. This is very important as it makes it much easier and quicker to build user interfaces.

\subsection{Deployment}
There are various techniques of deploying a technology stack to a production ready environment ranging from installing a webserver, database and additional services directly onto a server (monolith) to using virtual machines for each individual service. A much better and future-proof approach is the usage of "containers": Each service is encapsulated in its own linux environment but hosted on the same machine. It is important to note that some services are bundled together in the same container if it makes sense: E.g a backend framework which defines REST endpoints and a webserver which exposes these endpoints. A more appropriate word in this case is "microservice". The most popular containerization technology is Docker which gives developers the ability to write "compose" files that define a composition of services. One of the biggest advantages of Docker is that the same services can be run in a development as well as production environment, greatly reducing overhead.

\subsection{Webserver}
The two main webserver technologies are NGINX and Apache httpd. According to various statistics and benchmarks, NGINX can handle a vastly greater number of concurrent connections and can serve static content more efficiently, whereas httpd is better suited for handling dynamic content (e.g. PHP-generated sites). These two technologies however, are often used in tandem: NGINX used as a reverse proxy handling a great number of connections and httpd used to serve dynamic content. With the finished \acrfull{spa} consisting only of static content NGINX clearly is more suitable for this project.

\subsection{Summary}
Vue is the perfect framework for this project due to its flexibility and ease of learning. Nuxt will be used to lay the groundwork for \acrshort{ssr}. The design of the frontend will be based on Bulma and Buefy giving the project a distinct and distinguishable look. Docker will provide a way of easily deploying the application on any server and development environment. An NGINX-based webserver is used to serve the static frontend.

\section{Additional Tools and Techniques}
\subsubsection{GitLab}
GitLab not only serves as a Git-based \acrfull{vcs} but also as a container registry. The registry exposes an interface for uploading and downloading container images. This is especially useful for creating images on a local machine, uploading them to the registry and downloading them again onto a remote server where they should be deployed. Doing it this way completely removes the need of storing the source code for the whole project on the remote server and building it from source. Instead, the version number of the used image is increased in a compose file and the container gets updated accordingly when a redeployment is initiated.

\subsubsection{Git Flow}
Git Flow is a VCS methodology which is based around "features". In its most basic structure there is one master and develop branch accompanied by multiple feature branches (usually one feature per branch). The master branch should always be kept in a production-ready state, wheras the develop branch contains the actively developed project-source in which every finished feature branch is merged into. Additionally there are hotfix and release branches which support the others. Git Flow adds an abstraction layer to the development flow and greatly helps building applications by an iterative approach.

\subsubsection{Circle CI}
Automated testing is important when developing applications. It can reassure the developer that nothing will break and result in unexpected errors. Circle CI is a continuous integration platform which automatically tests code when certain rules are met. It works very well when used in addition to Git Flow and Docker: it can be set up to create a container with the projects source, builds it and runs its tests upon every change made to the develop or master branch or a pull request. Circle CI notifies its users if any step during this process failed preventing faulty code to ever reach a production state.

\section{Legal and Ethical Issues}
As identified in the Technical Report (see Appendix ...) there are two main areas of concern regarding ethical and legal issues: privacy and visual impairment. In order to use the service, users have to provide information about them, including name, email and home address which could lead to GDPR related issues. Providing access to the service to visually impaired users also poses an ethical issue as adaptions have to be carefully thought about.