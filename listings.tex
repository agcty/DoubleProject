\chapter{Additional Listings}

\begin{lstlisting}[caption=Auth Middleware, captionpos=b, style=htmlcssjs, label=authmiddleware]{Auth Middleware}
export default async function(context) {

  if (!context.store.getters["auth/isAuthenticated"]) {
    console.info("[MIDDLEWARE] Not authenticated, reading data from cookie...");
    try {
      let result = await context.store.dispatch("auth/initAuth");
      console.info(result);
    } catch (error) {
      console.info(error.message);
      if (error.code == "nocookies") {
        return context.redirect("/login");
      } else if (error.code == "expired") {
        await context.store.dispatch("auth/logout");
        return context.redirect("/login");
      } else if (error.code == "refresh") {
        try {
          await context.store.dispatch("auth/refreshAuth");
        } catch (error) {
          await context.store.dispatch("auth/logout");
          return context.redirect("/login");
        }
      }
    }
  } else if (
    //both tokens are too old cannot do anything -> logout (clear state)
    new Date() > new Date(context.store.state.auth.refresh_token_expiry)
  ) {
    console.info("[MIDDLEWARE] Tokens are expired, logging out...");
    await context.store.dispatch("auth/logout");
    return context.redirect("/login");
  } else if (
    //token is too old but refresh token still valid refresh
    new Date() > new Date(context.store.state.auth.token_expiry) &&
    new Date() < new Date(context.store.state.auth.refresh_token_expiry)
  ) {
    console.info("[MIDDLEWARE] Refresh token still valid, refreshing...");
    try {
      await context.store.dispatch("auth/refreshAuth");
    } catch (error) {
      await context.store.dispatch("auth/logout");
      return context.redirect("/login");
    }
  }
}
\end{lstlisting}

\newpage

\begin{lstlisting}[caption=Persisting Auth Data, captionpos=b, style=htmlcssjs, label=persauthdata]{Persisting Auth Data}
  saveTokenData({ commit }, result) {
  //set token data
  commit("SET", result);

  //set cookie data
  Cookie.set("token", result.token, { secure: false });
  Cookie.set("token_expiry", result.token_expiry, { secure: false });
  Cookie.set("refresh_token", result.refresh_token, { secure: false });
  Cookie.set("refresh_token_expiry", result.refresh_token_expiry, {
    secure: false
  });
  Cookie.set("user", result.user, { secure: false });

  // Adds header: `Authorization: Token token` to all requests
  this.$axios.setToken(result.token, "Token");
}
\end{lstlisting}

\begin{lstlisting}[caption=Axios Unauthorized Plugin, captionpos=b, style=htmlcssjs, label=unauthorized]{Axios Unauthorized Plugin}
  export default function({ $axios, app, store }) {
      $axios.onError(error => {
        if (!error.response) {
          // network error
          app.$toasted.global.my_error({
            message: "You are not connected to the internet"
          });
          return;
        }
        const code = parseInt(error.response && error.response.status);
        if (code === 401) {
          //don't do anything when coming from login page
          if ($nuxt.$route.name == "login") {
            return;
          }
    
          app.$toasted.global.my_error({
            message: "Token too old, logging you out!"
          });
    
          store.dispatch("auth/logout");
        }
      });
    }
\end{lstlisting}


\begin{lstlisting}[caption=Population Middleware, captionpos=b, style=htmlcssjs, label=popmiddleware]{Population Middleware}
  export default async function(context) {
  if (!context.store.getters["user/isPopulated"]) {
    try {
      await context.store.dispatch("user/getUser");
      await context.store.dispatch("tenement/getTenements");
      await context.store.dispatch("tenement/getDetails");
    } catch (error) {
      console.error(error);
    }
  }
}
\end{lstlisting}

\begin{lstlisting}[caption=Just in Case dispatched actions, captionpos=b, style=htmlcssjs, label=jicdispa]{Just in Case dispatched actions}
  export const actions = {
    resetState({ dispatch }) {
      dispatch("tenement/resetState", null, { root: true });
      dispatch("user/resetState", null, { root: true });
      dispatch("polls/resetState", null, { root: true });
      dispatch("forum/resetState", null, { root: true });
      dispatch("blackboard/resetState", null, { root: true });
      dispatch("documents/resetState", null, { root: true });
  
      console.log("[STORE] State was reset");
    },
  
    resetUserGeneratedData({ dispatch }) {
      dispatch("polls/resetState", null, { root: true });
      dispatch("forum/resetState", null, { root: true });
      dispatch("blackboard/resetState", null, { root: true });
      dispatch("documents/resetState", null, { root: true });
  
      console.log("[STORE] User generated data was reset");
    },
  
    populateState({ dispatch, getters }) {
      //dont get other data when we don't have any tenements to get data from
      if (!getters["tenement/numberOfTenements"]) {
        return;
      }
      //when populateState is executed we assume getTenements was executed some time before
      try {
        //solution where promise.all() is used might be better for efficiency
        dispatch("tenement/getDetails", null, { root: true });
        dispatch("polls/getPolls", null, { root: true });
        dispatch("forum/getThreads", null, { root: true });
        dispatch("blackboard/getBoards", null, { root: true });
        dispatch("issues/getIssues", null, { root: true });
  
        console.log("[STORE] State was populated");
      } catch (error) {
        this.$toasted.global.my_error();
      }
    }
  };
\end{lstlisting}

\begin{lstlisting}[caption=Just in Case Store Population on app run, captionpos=b, style=htmlcssjs, label=jic]{Just in Case on app run}
  async mounted() {
    try {
      this.$store.dispatch("populateState");
    } catch (error) {
      this.$toasted.global.my_error();
    }
  }
\end{lstlisting}

\newpage

\begin{lstlisting}[caption=Vue component without bundler, captionpos=b, style=htmlcssjs, label=compwobundler]{Vue component without bundler}
  Vue.component('todo-component', {
      template: '<h1> {{ newItem }} </h1>',
      data() {
          return {
              items: [
                  {
                      id: '1',
                      title: 'Buy milk',
                      completed: false
                  },
              ],
              newItem: ''
          };
      },
      methods: {
          addItem() {
            // LOGIC OMITTED FOR READABILITY
      }
  \end{lstlisting}

  \begin{lstlisting}[caption=Add Vote, captionpos=b, style=htmlcssjs, label=addvote]{Add Vote}
    ADD_VOTE(state, pollOptionId) {
      state.polls.some(o =>
        o.poll_answer_options.some(option => {
          if (option.id === pollOptionId) {
            option.votes++;
            //manually set showresults to true so rendering happens immediately in dashboard
            o.showResults = true;
            return true;
          }
        })
      );
    }
  \end{lstlisting}