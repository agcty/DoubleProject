\chapter{Additional Listings}

\begin{lstlisting}[caption=Auth Middleware, captionpos=b, style=htmlcssjs, label=authmiddleware]{Auth Middleware}
export default async function(context) {

  if (!context.store.getters["auth/isAuthenticated"]) {
    console.info("[MIDDLEWARE] Not authenticated, reading data from cookie...");
    try {
      let result = await context.store.dispatch("auth/initAuth");
      console.info(result);
    } catch (error) {
      console.info(error.message);
      if (error.code == "nocookies") {
        return context.redirect("/login");
      } else if (error.code == "expired") {
        await context.store.dispatch("auth/logout");
        return context.redirect("/login");
      } else if (error.code == "refresh") {
        try {
          await context.store.dispatch("auth/refreshAuth");
        } catch (error) {
          await context.store.dispatch("auth/logout");
          return context.redirect("/login");
        }
      }
    }
  } else if (
    //both tokens are too old cannot do anything -> logout (clear state)
    new Date() > new Date(context.store.state.auth.refresh_token_expiry)
  ) {
    console.info("[MIDDLEWARE] Tokens are expired, logging out...");
    await context.store.dispatch("auth/logout");
    return context.redirect("/login");
  } else if (
    //token is too old but refresh token still valid refresh
    new Date() > new Date(context.store.state.auth.token_expiry) &&
    new Date() < new Date(context.store.state.auth.refresh_token_expiry)
  ) {
    console.info("[MIDDLEWARE] Refresh token still valid, refreshing...");
    try {
      await context.store.dispatch("auth/refreshAuth");
    } catch (error) {
      await context.store.dispatch("auth/logout");
      return context.redirect("/login");
    }
  }
}
\end{lstlisting}

\newpage

\begin{lstlisting}[caption=Persisting Auth Data, captionpos=b, style=htmlcssjs, label=persauthdata]{Persisting Auth Data}
  saveTokenData({ commit }, result) {
  //set token data
  commit("SET", result);

  //set cookie data
  Cookie.set("token", result.token, { secure: false });
  Cookie.set("token_expiry", result.token_expiry, { secure: false });
  Cookie.set("refresh_token", result.refresh_token, { secure: false });
  Cookie.set("refresh_token_expiry", result.refresh_token_expiry, {
    secure: false
  });
  Cookie.set("user", result.user, { secure: false });

  // Adds header: `Authorization: Token token` to all requests
  this.$axios.setToken(result.token, "Token");
}
\end{lstlisting}

\begin{lstlisting}[caption=Axios Unauthorized Plugin, captionpos=b, style=htmlcssjs, label=unauthorized]{Axios Unauthorized Plugin}
  export default function({ $axios, app, store }) {
      $axios.onError(error => {
        if (!error.response) {
          // network error
          app.$toasted.global.my_error({
            message: "You are not connected to the internet"
          });
          return;
        }
        const code = parseInt(error.response && error.response.status);
        if (code === 401) {
          //don't do anything when coming from login page
          if ($nuxt.$route.name == "login") {
            return;
          }
    
          app.$toasted.global.my_error({
            message: "Token too old, logging you out!"
          });
    
          store.dispatch("auth/logout");
        }
      });
    }
\end{lstlisting}


\begin{lstlisting}[caption=Population Middleware, captionpos=b, style=htmlcssjs, label=popmiddleware]{Population Middleware}
  export default async function(context) {
  if (!context.store.getters["user/isPopulated"]) {
    try {
      await context.store.dispatch("user/getUser");
      await context.store.dispatch("tenement/getTenements");
      await context.store.dispatch("tenement/getDetails");
    } catch (error) {
      console.error(error);
    }
  }
}
\end{lstlisting}

\begin{lstlisting}[caption=Just in Case dispatched actions, captionpos=b, style=htmlcssjs, label=jicdispa]{Just in Case dispatched actions}
  export const actions = {
    resetState({ dispatch }) {
      dispatch("tenement/resetState", null, { root: true });
      dispatch("user/resetState", null, { root: true });
      dispatch("polls/resetState", null, { root: true });
      dispatch("forum/resetState", null, { root: true });
      dispatch("blackboard/resetState", null, { root: true });
      dispatch("documents/resetState", null, { root: true });
  
      console.log("[STORE] State was reset");
    },
  
    resetUserGeneratedData({ dispatch }) {
      dispatch("polls/resetState", null, { root: true });
      dispatch("forum/resetState", null, { root: true });
      dispatch("blackboard/resetState", null, { root: true });
      dispatch("documents/resetState", null, { root: true });
  
      console.log("[STORE] User generated data was reset");
    },
  
    populateState({ dispatch, getters }) {
      //dont get other data when we don't have any tenements to get data from
      if (!getters["tenement/numberOfTenements"]) {
        return;
      }
      //when populateState is executed we assume getTenements was executed some time before
      try {
        //solution where promise.all() is used might be better for efficiency
        dispatch("tenement/getDetails", null, { root: true });
        dispatch("polls/getPolls", null, { root: true });
        dispatch("forum/getThreads", null, { root: true });
        dispatch("blackboard/getBoards", null, { root: true });
        dispatch("issues/getIssues", null, { root: true });
  
        console.log("[STORE] State was populated");
      } catch (error) {
        this.$toasted.global.my_error();
      }
    }
  };
\end{lstlisting}

\begin{lstlisting}[caption=Just in Case Store Population on app run, captionpos=b, style=htmlcssjs, label=jic]{Just in Case on app run}
  async mounted() {
    try {
      this.$store.dispatch("populateState");
    } catch (error) {
      this.$toasted.global.my_error();
    }
  }
\end{lstlisting}

\newpage

\begin{lstlisting}[caption=Vue component without bundler, captionpos=b, style=htmlcssjs, label=compwobundler]{Vue component without bundler}
  Vue.component('todo-component', {
      template: '<h1> {{ newItem }} </h1>',
      data() {
          return {
              items: [
                  {
                      id: '1',
                      title: 'Buy milk',
                      completed: false
                  },
              ],
              newItem: ''
          };
      },
      methods: {
          addItem() {
            // LOGIC OMITTED FOR READABILITY
      }
  \end{lstlisting}

  \begin{lstlisting}[caption=Add Vote, captionpos=b, style=htmlcssjs, label=addvote]{Add Vote}
    ADD_VOTE(state, pollOptionId) {
      state.polls.some(o =>
        o.poll_answer_options.some(option => {
          if (option.id === pollOptionId) {
            option.votes++;
            //manually set showresults to true so rendering happens immediately in dashboard
            o.showResults = true;
            return true;
          }
        })
      );
    }
  \end{lstlisting}

  \begin{lstlisting}[caption=Production Docker Compose File, captionpos=b, style=htmlcssjs, label=dockerprod]{Production Docker Compose File}
    version: "3.7"
    #postgres redis frontend backend traefik logger(postgres)
    services:
      web:
        image: registry.gitlab.com/agcty/hausversammlung/hv-frontend:v1.0.2
        command: ["nginx", "-g", "daemon off;"]
        depends_on:
          - backend
        networks:
          - default
          - traefik-public
        ports:
          - "80"
        deploy:
          replicas: 1
          labels:
            - traefik.enable=true
            - traefik.backend=Web
            - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}
            - traefik.docker.network=traefik-public
            - traefik.frontend.rule=Host:${DOMAIN}
            - traefik.port=80
            # Traefik service that listens to HTTP
            - traefik.redirectorservice.frontend.entryPoints=http
            - traefik.redirectorservice.frontend.redirect.entryPoint=https
            # Traefik service that listens to HTTPS
            - traefik.webservice.frontend.entryPoints=https
      backend:
        image: registry.gitlab.com/agcty/hausversammlung/hv-backend:v1.0.2
        entrypoint: ["sh", "entrypoint.sh"]
        command: ["uwsgi", "--http", ":8080", "--ini", "./uwsgi.ini"]
        depends_on:
          - db
          - redis
        networks:
          - default
          - traefik-public
        ports:
          - "8080"
        secrets:
          - source: backend_passwords
            target: backend-passwords.json
        deploy:
          replicas: 1
          labels:
            - traefik.enable=true
            - traefik.backend=Api
            - traefik.tags=${TRAEFIK_PUBLIC_TAG:-traefik-public}
            - traefik.docker.network=traefik-public
            - traefik.frontend.rule=Host:api.${DOMAIN}
            - traefik.port=8080
            # Traefik service that listens to HTTP
            - traefik.redirectorservice.frontend.entryPoints=http
            - traefik.redirectorservice.frontend.redirect.entryPoint=https
            # Traefik service that listens to HTTPS
            - traefik.webservice.frontend.entryPoints=https
        environment:
          #hausversammlung
          - SQL_ENGINE=django.db.backends.postgresql
          - SQL_DATABASE=hausversammlung
          - SQL_USER=hausversammlung
          - SQL_HOST=db
          - SQL_PORT=5432
          #hausversammlung logger
          - SQL_DATABASE_LOGGER=hausversammlung_logger
          - SQL_USER_LOGGER=hausversammlung_logger
      db: 
        image: registry.gitlab.com/agcty/hausversammlung/hv-db:v1.0.0
        ports:
          - 5432:5432
        volumes:
          - postgres_data:/var/lib/postgresql/data/
      #redis
      redis:
        image: redis:5.0.3-alpine3.9
        ports:
          - 6379:6379
        volumes:
          - redis_data:/data
        networks:
          - default
          - traefik-public
    
    secrets:
      backend_passwords:
        name: backend_passwords_v2
        file: ./backend-passwords.json
      
    volumes:  
      redis_data:
      postgres_data:
    
    networks:
      traefik-public:
        external: true
    
  \end{lstlisting}


\begin{lstlisting}[caption=LoginForm tests, captionpos=b, style=htmlcssjs, label=loginformtest]{LoginForm tests}
import { createLocalVue, shallowMount } from "@vue/test-utils";
// import flushPromises from "flush-promises";
import { isFormValid } from "~/plugins/utils/vee-validate-formcheck.js";
import LoginForm from "../LoginForm";
import { getters } from "@/store/auth";
import buefy from "buefy";
import VeeValidate from "vee-validate";
import Vuex from "vuex";
import VueRouter from "vue-router";

//set sync in component to false to prevent vee-validate errors as described in https://github.com/baianat/vee-validate/issues/1267

const localVue = createLocalVue();
localVue.use(VeeValidate);
localVue.use(Vuex);
localVue.use(buefy);
localVue.use(VueRouter);
localVue.mixin({
  computed: {
    isFormValid
  }
});

let actions;
let state;
let store;

const factory = () => {
  return shallowMount(LoginForm, {
    store,
    localVue,
    sync: false,
    attachToDocument: true //https://github.com/vuejs/vue-test-utils/issues/1030
  });
};

describe("LoginForm", () => {
  beforeEach(() => {
    state = {
      isLogin: false
    };

    actions = {
      moduleActionClick: jest.fn()
    };

    store = new Vuex.Store({
      modules: {
        auth: {
          //need this to work with namespaced module https://vuex.vuejs.org/guide/modules.html#namespacing
          namespaced: true,
          state,
          actions,
          getters
        }
      }
    });
  });

  test("shallowMounts properly", () => {
    const wrapper = factory();
    expect(wrapper.isVueInstance()).toBeTruthy();
  });

  test("renders properly", () => {
    const wrapper = factory();
    expect(wrapper.html()).toMatchSnapshot();
  });

  test("calls onSubmit on button click when form is provided with correctly formatted data", async () => {
    const wrapper = factory();
    const onSubmitMock = jest.fn();
    wrapper.setMethods({
      onSubmit: onSubmitMock
    });
    const button = wrapper.find("button");

    wrapper.setData({
      authData: { username: "alex@gogl.io", password: "HalloHallo1!" }
    });

    expect(button.classes()).toContain("button", "is-primary", "is-fulldwidth");
    button.trigger("click");
    expect(onSubmitMock).toHaveBeenCalled();
  });
});

\end{lstlisting}