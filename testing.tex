\chapter[Test Strategy]{Test Strategy}

\section{Introduction}
In order to ensure correct functionality and fulfillment of the requirements a test strategy was implemented. Common ways of testing frontend applications include "Unit Testing", "Snapshot Testing", "End to End Testing" and "Integration Testing". Given the projects size and its time constraints, not all features could be tested, also not every possible testing methodolgy was sensible to be utilized. The project's testing strategy is based on Unit and Snapshot testing, with a special focus on the most import aspects and features of the application. Furthermore, a pre-emptive and heuristic approach was chosen. 

\section{Testing Methodologies}

\subsection{Unit Testing}
The testing strategy consists of a pre-emptive and heuristic approach (see \autoref{preheur}), based on Unit and Snapshot testing.
Unit testing is a way of testing the functional aspects of software components. In Blackbox testing, there is no knowledge of the internals of a component such as data structures, properties or methods. Whitebox testing on the other hand, is closely coupled to a component's internals. The mixture between blackbox and whitebox is called "Greybox Testing", which is also a common methodology \cite{spillner2014software} and used as an approach of Unit for this project.

\subsection{Snapshot Testing}
Snapshot tests are a useful tool for making sure the rendered UI does not change unexpectedly \cite{SnapshotJest:online}.

A very comprehensible explanation is provided by Jest - a Snapshot testing library \cite{SnapshotJest:online}:

\begin{quotation}
"A typical snapshot test case for a mobile app renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component."
\end{quotation}

\subsection{Pre-emptive and Heuristic Approach} \label{preheur}
As there is no way of objectively defining the priority with which a component should be tested from the given requirements, a heuristic approach of testing "which relies on experience and rules of thumb" \cite{spillner2014software} was chosen. Based on my personal experience and recommendations of the Vue community, I concluded that all Single File Components of the /components folder should be tested, whereas pages should not be tested as they are "just" containers for the components. In addition to a heuristic approach, it was sensible to follow a pre-emptive testing approach which means testing is carried out from project start \cite{spillner2014software}. This also complements the iterative development approach and continuous integration. 

\section{Test Setup}
The test set up is built upon two external libraries: "vue-test-utils" - the official testing library for vue applications and "Jest" - a JavaScript testing library. While Jest is used for general JavaScript test scenarios such as "has a button been clicked" or "is a class added when this condition applies", snapshot testing and to generate code coverage, "vue-test-utils" is needed for Vue-specific scenarios and set up. This includes checking if a computed property is has the right value or checking if the underlying Vue instance is created properly.

For every component-group (e.g every component in /Auth folder) a "\_\_test\_\_" folder is created which contains the tests for this group. In general the following tests are executed for every tested component: testing if a component mounts properly on the Vue instance and if it renders properly and matches the stored snapshot. Depending on the component and its functionality, different tests are applied. For example a specific test for the LoginForm.vue component tests the following scneario: if username and password are supplied to the form and both are formatted correctly and the submit button is clicked, the onSubmit() method of the component should have been called.

Testing the previous examples may sound trivial but it is important to note that in order to be able to execute a test, the component needs to be embedded into an appropriate environment. Setting up this environment however, differs from component to component. For example the LoginForm.vue component uses the translation plugin, communicates with the Vuex store and requires VeeValidate to validate form input. This means that the entire store (or the needed module of the store), the translation plugin and VeeValidate have to be mocked. The corresponding code sample for these scenarios can be found in \autoref{loginformtest}.

In addition, by default every test uses a global Vue instance which is easily polluted if various tests mock different plugins and libraries. To mitigate this issue, a "local" Vue instance was used which essentially means that every test has its own isolated Vue environment. This makes the test setup significantly more complicated but mitigates the risk of global pollution and results in more comprehensible tests. 

\section{Continuous Integration}
Gitlab CI / CD

\section{Linting}