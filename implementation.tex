\chapter[Implementation]{Implementation} \label{ch:implementation}

\section{Introduction}
Based on the evaluation carried out in \autoref{sec:consideredtech} the \acrlong{spa} was implemented with Vue and Nuxt. To give the reader a better understanding of how the application was built, the first few sections of this chapter will discuss which additional tools and functionalities Nuxt provides, how Vue is used and \acrfull{soc} is achieved and briefly illustrates how the frontend and the API communicate with each other. 

\section{Nuxt.js}
Nuxt's primary use case is to provide \acrlong{ssr} for Vue-based applications. It also advertises itself as a framework which "presets all the configuration needed to make your development of a Vue.js application enjoyable" \cite{Nuxtjs:online}. While this blurry description is not very meaningful on its own, it indicates that Nuxt pre-configures certain parts of a Vue application. The most important of which are: \acrlong{ssr}, automatic setup of routing and store management.

\subsection{Rendering modes}
Nuxt offers three rendering modes: \acrshort{ssr}, "Prerendering" and "Single Page Application". For descriptions of the first two please see \autoref{sub:seo}. The "Single Page Application" mode does not offer server-rendering capabilities while still pre-configuring routing and state management. This mode is especially useful for applications that require users to be authenticated before being able to use them. The reason why is simple: \acrlong{ssr} can only improve the SEO ranking of a page if crawlers are able to look at the full contents of it. Fully implementing \acrshort{ssr} for an application that only shows a login form would therefore be pointless. 

Then why should this project use Nuxt, which is primarily used for \acrshort{ssr} if the application cannot even profit from it because authentication prevents crawlers from seeing anything but a login form? The answer is because 1) state management and routing are auto-configured as well and 2) because in the future, the frontend might expose parts of the system in a publicly accessible way without the need of authentication. By using Nuxt from the beginning, the transition to this is much easier.

\subsection{Usage}
When using Nuxt, different folders contain different parts of the frontend application. Behind the scenes, Webpack - one of the most popular bundler tools consolidates, minifies, transforms and transpiles the code of these folders into browser-readable plain JavaScript code. 

\begin{table}
    \begin{tabularx}{\linewidth}{|l|X|}
        \hline
        \textbf{Folder} & \textbf{Description} \\
        \hline
        assets & contains un-compiled assets such as images, global css or fonts  \\
        \hline
        components & contains reusable Vue Single File Components \\
        \hline
        layouts & contains Vue files that define the applications theme \\
        \hline
        middleware & defines files which are run before a route changes, e.g check if user is authenticated before redirecting \\
        \hline
        pages & contains the pages of the application, Nuxt automatically creates routes corresponding to a page's name \\
        \hline
        plugins & contains plain JavaScript files which are run before instantiating the application, e.g used for inject adding an internationalization plugin \\
        \hline
        static & files in this is directory are directly mapped to server root and are not compiled or renamed in any way, e.g robots.txt \\
        \hline
        store & contains Vuex store files, every file added in this directory is automatically mapped to the global store \\
        \hline
        nuxt.config.js & contains the Nuxt configuration for the application, e.g which plugins and middleware to use\\
        \hline
        package.json & is not Nuxt specific but added by npm and contains application dependencies and scripts \\
        \hline
    \end{tabularx}
    \caption{Nuxt File Structure}
    \label{table:filestructure}
\end{table}

Typically, functional components are defined inside the components folder. These components might include other components in order to compose more complex architectures. Pages and layouts are also nothing more than Vue components, however, they are used in very specific ways. The file structure of the pages folder is automatically read by Nuxt and routes are generated from it. For example the file pages/index.vue is shown when a user visits \url{hausversammlung.at}, whereas the file pages/issues/index.vue translates to the url \url{hausversammlung.at/issues/}. Layouts are used to change the look and feel of the application. For example it is possible to create a layout file which includes a navigation bar on the top of the page. Nuxt then allows developers to set a layout property inside a page which corresponds to a layout file, resulting in easily reusable themes. 

\section{Vue}
This section aims to extend the basic description of Vue's usage as described in \autoref{subsub:vueusage} so that code samples of this chapter are more easily understood. For the sake of brevity, some parts will be omitted if they are not crucially relevent (e.g transitions). 

Discusses:
Single File Components separated into HTML, JS and CSS
v-bind and shorthand, v-model
ternary expressions
events how they are emitted and caught
props
methods
computed properties
v-if 
conditional classes 
vuex store
routing

\section{Separation of Concerns}
A very important aspect of modern software architectures is \acrfull{soc} which is often regarded to as principles of modularization of code and object-oriented design \cite{laplante2007every:book}. In the case of traditional web design HTML, CSS and JavaScript are often physically separated (separation of file types) leading to increased maintainability of code, a less tightly coupled system and decreased probability of violating DRY principles. Furthermore, it helps building complex layered systems which can be actively worked on by multiple developers. 

Vue however, takes different approaches on \acrshort{soc} depending on the way it is used in a project:
either Vue.js is added to existing sites by using a standard HTML script tag or by using a complete bundling tool like Webpack or Browserify to add it as a dependency. Using Vue by adding a script tag has some disadvantages: it only allows developers to target a specific HTML container element on the page Vue is embedded in, and also brings certain disadvantages such as no CSS support inside the Vue component itself and no build steps which requires the developer to fall back to plain HTML and ES5 JavaScript rather than using various preprocessors.

\begin{lstlisting}[caption=Vue component without bundler, captionpos=b, style=htmlcssjs]{Vue component without bundler}
Vue.component('todo-component', {
    template: '<h1> {{ newItem }} </h1>',
    data() {
        return {
            items: [
                {
                    id: '1',
                    title: 'Buy milk',
                    completed: false
                },
            ],
            newItem: ''
        };
    },
    methods: {
        addItem() {
            // LOGIC OMITTED FOR READABILITY
        }
\end{lstlisting}
The more preferable approach would be to use a so called “Single File Component”, a file with a “.vue” extension. These files however have to be compiled with build tools like Webpack or Browserify to extract the corresponding concerns. A sample file is depicted in \autoref{lst:sfc}.

\begin{lstlisting}[caption=Vue Single File Component, label={lst:sfc}, captionpos=b, style=htmlcssjs]{Vue Single File Component}
<template>
  //HTML
  <p>{{ text }}</p>
</template>

<script>
//JS
export default {
  data() {
    return {
      text: 'Hello World!'
    }
  }
}
</script>

<style scoped>
//CSS
  p {
    color: red;
  }
</style>
\end{lstlisting}

By defining .vue files developers can utilize syntax highlighting, linting and component-scoped CSS. Furthermore preprocessors like Pug, Babel or SASS can be used to further improve the development process. This however comes with an important tradeoff: as Single File Components rely on the use of build tools, they are not very suitable projects which are not completely vue-based

Clearly HTML, CSS and JavaScript are not separated into their own respective files even when using Single File Components which leaves us with the question of how Separation of Concerns is achieved. As stated in the Vue Documentation: 

\begin{quotation}
“... separation of concerns is not equal to separation of file types. In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable \cite{VueSeparationofConcerns:online}.” 
\end{quotation}

Instead of creating different files in which logic, presentation and design reside in, Vue consolidates these tiers into a single file, hence the name “Single File Component”, making it more maintainable and editable in the process.

\section{API Endpoints}

\section{Authentication / Authorization}

\section{Forum}

\section{Polls}

\section{Noticeboard}

\section{Issue Log System}

\section{State Management}

\section{Internationalization}

\section{Linting}