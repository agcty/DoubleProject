\chapter[Implementation]{Implementation}

\section{Introduction}
Based on the evaluation carried out in \autoref{sec:consideredtech} the \acrlong{spa} was implemented with Vue and Nuxt. To give the reader a better understanding of how the application was built, the first few sections of this chapter will discuss which additional tools and functionalities Nuxt provides, how \acrfull{soc} is achieved with Vue and briefly illustrates how the frontend and the API communicate with each other. 

\section{Nuxt.js}
Nuxt's primary use case is to provide \acrlong{ssr} for Vue-based applications. It also advertises itself as a framework which "presets all the configuration needed to make your development of a Vue.js application enjoyable" \cite{Nuxtjs:online}. While this blurry description is not very meaningful on its own, it indicates that Nuxt pre-configures certain parts of a Vue application. The most important of which are: \acrlong{ssr}, automatic setup of routing and store management.

\subsection{Rendering modes}
Nuxt offers three rendering modes: \acrshort{ssr}, "Prerendering" and "Single Page Application". For descriptions of the first two please see \autoref{sub:seo}. The "Single Page Application" mode does not offer server-rendering capabilities while still pre-configuring routing and state management. This mode is especially useful for applications that require users to be authenticated before being able to use them. The reason why is simple: \acrlong{ssr} can only improve the SEO ranking of a page if crawlers are able to look at the full contents of it. Fully implementing \acrshort{ssr} for an application that only shows a login form would therefore be pointless. 

Then why should this project use Nuxt, which is primarily used for \acrshort{ssr} if the application cannot even profit from it because authentication prevents crawlers from seeing anything but a login form? The answer is because 1) state management and routing are auto-configured as well and 2) because in the future, the frontend might expose parts of the system in a publicly accessible way without the need of authentication. By using Nuxt from the beginning, the transition to this is much easier.

\section{Nuxt Folder Structure}
When using Nuxt, different folders contain different parts of the frontend application. Behind the scenes, Webpack - one of the most popular bundler tools consolidates, minifies, transforms and transpiles the code of these folders into browser-readable plain JavaScript code. 

\begin{table}
    \begin{tabularx}{\linewidth}{|l|X|}
        \hline
        \textbf{Folder} & \textbf{Description} \\
        \hline
        assets & contains un-compiled assets such as images, global css or fonts  \\
        \hline
        components & contains reusable Vue Single File Components \\
        \hline
        layouts & contains Vue files that define the applications theme \\
        \hline
        middleware & defines files which are run before a route changes, e.g check if user is authenticated before redirecting \\
        \hline
        pages & contains the pages of the application, Nuxt automatically creates routes corresponding to a page's name \\
        \hline
        plugins & contains plain JavaScript files which are run before instantiating the application, e.g used for inject adding an internationalization plugin \\
        \hline
        static & files in this is directory are directly mapped to server root and are not compiled or renamed in any way, e.g robots.txt \\
        \hline
        store & contains Vuex store files, every file added in this directory is automatically mapped to the global store \\
        \hline
        nuxt.config.js & contains the Nuxt configuration for the application, e.g which plugins and middleware to use\\
        \hline
        package.json & is not Nuxt specific but added by npm and contains application dependencies and scripts \\
        \hline
    \end{tabularx}
    \caption{Folder Structure}
    \label{table: simulation parameters}
\end{table}

\section{Separation of Concerns}
In modern software architectures “Separation of Concerns” plays an important role and is often found as principles of modularization of code and object-oriented design. In the case of web design the physical separation of HTML, CSS and JavaScript as different files leads to increased maintainability of code, a less tightly coupled system and decreased probability of violating DRY principles. Furthermore, it helps building complex layered systems which can be actively worked on by multiple developers.  Naturally we want the same benefits in the frontend framework of our choice.

Vue takes different approaches on SoC depending on the way it is used in a project:
One way is to add the Vue.js framework to existing sites as an external script in order to enhance certain views, not however to build complete frontends.  When doing so it is only possible to use Vue components in an intertwined fashion leaving little to no trail of SoC:

\begin{lstlisting}[caption=Vue Single File Component, captionpos=b, style=htmlcssjs]{Vue Single File Component}
Vue.component('todo-component', {
    template: '<h1> {{ newItem }} </h1>',
    data() {
        return {
            items: [
                {
                    id: '1',
                    title: 'Buy milk',
                    completed: false
                },
            ],
            newItem: ''
        };
    },
    methods: {
        addItem() {
            // LOGIC OMITTED FOR READABILITY
        }
\end{lstlisting}

Using it in such a fashion merely allows you to target a specific html container element on the page Vue is embedded in and also brings certain disadvantages such as no CSS support inside the Vue component itself and no build steps which requires the developer to fall back to plain HTML and ES5 JavaScript rather than using various preprocessors.

The more preferable approach would be to use a so called “Single File Component”, a file with a “.vue” extension. These files however have to be compiled with build tools like Webpack or Browserify to extract the corresponding concerns. A sample file is presented below:

\begin{lstlisting}[caption=Vue Single File Component, captionpos=b, style=htmlcssjs]{Vue Single File Component}
<template>
  //HTML
  <p>{{ text }}</p>
</template>

<script>
//JS
export default {
  data() {
    return {
      text: 'Hello World!'
    }
  }
}
</script>

<style scoped>
//CSS
  p {
    color: red;
  }
</style>
\end{lstlisting}

By defining .vue files developers can utilize syntax highlighting, linting and component-scoped CSS. Furthermore preprocessors like Pug, Babel or SASS can be used to further improve the development process. This however comes with an important tradeoff: As Single File Components rely on the use of build tools, they are not specially suitable for use in projects which just use Vue on for enhancements to existing sites. 

Clearly HTML, CSS and JavaScript is not separated into their own respective files even when using Single File Components which leaves us with the question of how Separation of Concerns is achieved. As stated in the Vue Documentation: 

“... separation of concerns is not equal to separation of file types. In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.” 

Instead of creating different files in which logic, presentation and design reside in, Vue consolidates these tiers into a single file, hence the name “Single File Component”, making it more maintainable and editable in the process.



\section{API Endpoints}

\section{Authentication / Authorization}

\section{Forum}

\section{Polls}

\section{Noticeboard}

\section{Issue Log System}

\section{State Management}

\section{Internationalization}

\section{Linting}